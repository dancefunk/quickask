(window.webpackJsonp=window.webpackJsonp||[]).push([[241],{808:function(n,s,e){"use strict";e.r(s);var a=e(5),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"原子性和事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子性和事务"}},[n._v("#")]),n._v(" 原子性和事务")]),n._v(" "),e("h1",{attrs:{id:"mongodb原子性和事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mongodb原子性和事务"}},[n._v("#")]),n._v(" MongoDB原子性和事务")]),n._v(" "),e("p",[n._v("在MongoDB中，写操作的原子性是在"),e("code",[n._v("document")]),n._v("级别上的，即使修改的是文档中的内嵌部分，写锁的级别也是"),e("code",[n._v("document")]),n._v("上。")]),n._v(" "),e("p",[n._v("当一个写操作要修改多个文档，每个文档的修改是原子性的。整个的写操作并不是原子性的，它可能和其他写操作产生交织。然而你可以使用"),e("code",[n._v("$isolated")]),n._v("隔离操作符来限制写操作，让它不与其他写操作交织。 不隔离性能更高，但是会产生数据的不确定性，隔离写操作，事务性更好。MongoDB把这个级别完全由用户控制。")]),n._v(" "),e("h1",{attrs:{id:"隔离写操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隔离写操作"}},[n._v("#")]),n._v(" 隔离写操作")]),n._v(" "),e("p",[n._v("MongoDB使用"),e("code",[n._v("$isolated")]),n._v("操作符来隔离写操作。如果一个写操作要更新多个文档，它能防止其他进程与本次写操作交错。直到这个写操作完成，其他进程才能写。")]),n._v(" "),e("p",[n._v("但是，"),e("code",[n._v("$isolated")]),n._v("算不上一个事务，如果在写的过程中发生错误，MongoDB并不会回滚已经写的数据。"),e("code",[n._v("$isolated")]),n._v("也不能在分片集群上工作。")]),n._v(" "),e("p",[n._v("特性：")]),n._v(" "),e("ul",[e("li",[n._v("隔离不支持分片集群")]),n._v(" "),e("li",[n._v("不支持“all-or-nothing”特性")]),n._v(" "),e("li",[n._v("MongoDB2.2版本后"),e("code",[n._v("$isolated")]),n._v("被替换成"),e("code",[n._v("$atomic")])])]),n._v(" "),e("h1",{attrs:{id:"类事务语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类事务语法"}},[n._v("#")]),n._v(" 类事务语法")]),n._v(" "),e("p",[n._v("MongoDB并不支持关系型数据库中的那种事务特性，为了性能着想，它把这个特性交给程序员去实现。这就是MongoDB官方所讲的"),e("a",{attrs:{href:"http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits",target:"_blank",rel:"noopener noreferrer"}},[n._v("Two Phase Commits"),e("OutboundLink")],1),n._v("两阶段提交。这个技术虽然在一定程度上能保证数据最终的一致性，但是应用程序还是可能会读到提交或者回滚过程中的中间数据。对于这个技术如果有兴趣可以读一读原文。")]),n._v(" "),e("p",[n._v("#并发控制#")]),n._v(" "),e("p",[n._v("并发控制允许多个应用层程序同时访问数据库，而不引起数据不一致或冲突。")]),n._v(" "),e("p",[n._v("MongoDB中提到两种技术来解决这个问题。第一种是唯一索引，第二种是叫"),e("code",[n._v("Update if Current")]),n._v("。")]),n._v(" "),e("p",[n._v("用唯一索引来防止多个进程重复插入或者更新导致的重复的值。\n"),e("code",[n._v("Update if Current")]),n._v("意思是说在更新数据的时候，在更新条件里给定一个期望的值（这个值是先查询出来的），用来防止在更新之前其他进程已经将此值更新。看一个例子:")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('var myDocument = db.products.findOne( { sku: "abc123" } );\n\nif ( myDocument ) {\n   var oldQuantity = myDocument.quantity;\n   var oldReordered = myDocument.reordered;\n\n   var results = db.products.update(\n      {\n        _id: myDocument._id,\n        quantity: oldQuantity,\n        reordered: oldReordered\n      },\n      {\n        $inc: { quantity: 50 },\n        $set: { reordered: true }\n      }\n   )\n\n   if ( results.hasWriteError() ) {\n      print( "unexpected error updating document: " + tojson(results) );\n   }\n   else if ( results.nMatched === 0 ) {\n      print( "No matching document for " +\n             "{ _id: "+ myDocument._id.toString() +\n             ", quantity: " + oldQuantity +\n             ", reordered: " + oldReordered\n             + " } "\n      );\n   }\n}\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br")])]),e("p",[n._v("同样的，在findAndModify()函数中:")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('db.people.findAndModify({\n    query: { name: "Andy" },\n    sort: { rating: 1 },\n    update: { $inc: { score: 1 } },\n    upsert: true\n})\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("p",[n._v("如果有多个进程同时调用此函数，这些进程都完成了查询阶段，如果"),e("code",[n._v("name")]),n._v("字段上没有唯一索引，upsert阶段的操作，多个进程可能都会执行。导致写入重复的文档。")])])}),[],!1,null,null,null);s.default=t.exports}}]);