import{_ as o,p as e,q as d,Y as n}from"./framework-e1bed10d.js";const c={},a=n('<h3 id="journaling日志机制" tabindex="-1"><a class="header-anchor" href="#journaling日志机制" aria-hidden="true">#</a> Journaling日志机制</h3><hr><p>运行MongoDB如果开启了journaling日志功能，MongoDB先在内存保存写操作，并记录journaling日志到磁盘，然后才会把数据改变刷入到磁盘上的数据文件。为了保证journal日志文件的一致性，写日志是一个原子操作。本文将讨论MongoDB中journaling日志的实现机制。</p><h1 id="journal日志文件" tabindex="-1"><a class="header-anchor" href="#journal日志文件" aria-hidden="true">#</a> Journal日志文件</h1><p>如果开启了journal日志功能，MongoDB会在数据目录下创建一个<code>journal</code>文件夹，用来存放预写重放日志。同时这个目录也会有一个<code>last-sequence-number</code>文件。如果MongoDB安全关闭的话，会自动删除此目录下的所有文件，如果是崩溃导致的关闭，不会删除日志文件。在MongoDB进程重启的过程中，journal日志文件用于自动修复数据到一个一致性的状态。</p><p>journal日志文件是一种往文件尾不停追加内容的文件，它命名以<code>j._</code>开头，后面接一个数字（从0开始）作为序列号。如果文件超过1G大小，MongoDB会新建一个journal文件<code>j._1</code>。只要MongoDB把特定日志中的所有写操作刷入到磁盘数据文件，将会删除此日志文件。因为数据已经持久化，不再需要用它来重放恢复数据了。journal日志文件一般情况下只会生成两三个，除非你每秒有大量的写操作发生。</p><p>如果你需要的话，你可以使用<code>storage.smallFiles</code>参数来配置journal日志文件的大小。比如配置为<code>128M</code>。</p><h1 id="journaling机制的存储视图" tabindex="-1"><a class="header-anchor" href="#journaling机制的存储视图" aria-hidden="true">#</a> Journaling机制的存储视图</h1><p>Journaling功能用到了MongoDB存储层数据集内部的两个视图。</p><p><code>shared</code>视图保存数据修改操作，用于刷入到磁盘数据文件。<code>shared</code>视图是MongoDB中唯一访问磁盘数据文件的视图。<code>mongod</code>进程请求操作系统把磁盘数据文件映射到虚拟内存的<code>shared</code>视图。操作系统只是映射数据与内存关系，并不马上加载数据到内存。当查询需要的时候，才会加载数据到内存，即按需加载。</p><p><code>private</code>视图存储用于查询操作的数据。同时<code>private</code>视图也是MongoDB执行写操作的第一个地方。一旦journal日志提交完成，MongoDB会复制<code>private</code>视图中的改变到<code>shared</code>视图，再通过<code>shared</code>视图将数据刷入到磁盘数据文件。</p><p><code>journal</code>视图是一个用来保证新的写操作的磁盘视图。当MongoDB在<code>private</code>视图执行完写操作后，在数据刷入磁盘之前，会先记录<code>journal</code>日志。<code>journal</code>日志保证了持久性。如果<code>mongod</code>实例在数据刷入磁盘之前崩溃，重启过程中<code>journal</code>日志会重放并写入<code>shared</code>视图，最终刷入磁盘持久化。</p><h1 id="journaling如何纪录写操作" tabindex="-1"><a class="header-anchor" href="#journaling如何纪录写操作" aria-hidden="true">#</a> Journaling如何纪录写操作</h1><p>MongoDB采用<code>group commits</code>方式将写操作批量复制到<code>journal</code>日志文件中。<code>group commits</code>提交方式能够最小化journal日志机制对性能的影响。因此<code>group commits</code>方式在提交过程中必须阻塞所有写入。<code>commitIntervalMs</code>参数可以用于配置日志提交的频率，默认是100ms。</p><p>Journaling存储以下原始操作：</p><ul><li>文档插入或更新</li><li>索引修改</li><li>命名空间文件元数据的修改</li><li>创建和者删除数据库或关联的数据文件</li></ul><p>当发生写操作，MongoDB首先写入数据到内存中的<code>private</code>视图，然后批量复制写操作到<code>journal</code>日志文件。写个<code>journal</code>日志实体来用描述写操作改变数据文件的哪些字节。</p><p>MongoDB接下来执行<code>journal</code>的写操作到<code>shared</code>视图。此时，<code>shared</code>视图与磁盘数据文件不一样。</p><p>默认每60s钟，MongoDB请求操作系统将<code>shared</code>视图刷入到磁盘。使数据文件更新到最新的写入状态。如果系统内存资源不足的时候，操作系统会选择以更高的频率刷入<code>shared</code>视图到磁盘。</p><p>MongoDB刷入数据文件完成后，会通知<code>journal</code>日志已经刷入。一旦<code>journal</code>日志文件只包含全部刷入的写操作，不再用于恢复，MongoDB会将它删除或者作为一个新的日志文件再次使用。</p><p>作为journaling机制的一部分，MongoDB会例行性请求操作系统重新将<code>shared</code>视图映射到<code>private</code>视图，为了节省物理内存。一旦发生重映射，操作系统能够识别到可以在<code>private</code>视图和<code>shared</code>视图共享的内存页映射。</p><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>Journaling是MongoDB中非常重要的一项功能，类似于关系数据库中的事务日志。Journaling能够使MongoDB数据库由于意外故障后快速恢复。MongoDB2.0版本后默认开启了Journaling日志功能，<code>mongod</code>实例每次启动时都会检查<code>journal</code>日志文件看是否需要恢复。由于提交<code>journal</code>日志会产生写入阻塞，所以它对写入的操作有性能影响，但对于读没有影响。在生产环境中开启Journaling是很有必要的。</p>',23),r=[a];function l(i,u){return e(),d("div",null,r)}const h=o(c,[["render",l],["__file","10.html.vue"]]);export{h as default};
